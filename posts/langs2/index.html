<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>AK  | Rust 101</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.54.0" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.e08a958ae3e530145318b6373195c765.css" rel="stylesheet">
    

    

    
      
    

    

    <meta property="og:title" content="Rust 101" />
<meta property="og:description" content="Introduction To keep the research in , I started some basic repository with the some official Rust book code compilation, I will try in this post comment some of the features and tricks I got while reading it:
https://github.com/knabben/spec-lang/tree/master/go https://github.com/knabben/spec-lang/tree/master/rust Guess Tag 0.0.1 println! is used to send the value to stdout.
let mut guess = String::new();  For rust you can create an immutable and a mutable variable, this is defined with the mut keyword in front." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://knabben.github.io/posts/langs2/" />
<meta property="article:published_time" content="2019-07-04T08:00:00-04:00"/>
<meta property="article:modified_time" content="2019-07-04T08:00:00-04:00"/>

<meta itemprop="name" content="Rust 101">
<meta itemprop="description" content="Introduction To keep the research in , I started some basic repository with the some official Rust book code compilation, I will try in this post comment some of the features and tricks I got while reading it:
https://github.com/knabben/spec-lang/tree/master/go https://github.com/knabben/spec-lang/tree/master/rust Guess Tag 0.0.1 println! is used to send the value to stdout.
let mut guess = String::new();  For rust you can create an immutable and a mutable variable, this is defined with the mut keyword in front.">


<meta itemprop="datePublished" content="2019-07-04T08:00:00-04:00" />
<meta itemprop="dateModified" content="2019-07-04T08:00:00-04:00" />
<meta itemprop="wordCount" content="930">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Rust 101"/>
<meta name="twitter:description" content="Introduction To keep the research in , I started some basic repository with the some official Rust book code compilation, I will try in this post comment some of the features and tricks I got while reading it:
https://github.com/knabben/spec-lang/tree/master/go https://github.com/knabben/spec-lang/tree/master/rust Guess Tag 0.0.1 println! is used to send the value to stdout.
let mut guess = String::new();  For rust you can create an immutable and a mutable variable, this is defined with the mut keyword in front."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="http://knabben.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      AK
    </a>
    <div class="flex-l items-center">
      
      









    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  <article class="flex-l flex-wrap justify-between mw8 center ph3 ph0-l">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        POSTS
      </p>
      <h1 class="f1 athelas mb1">Rust 101</h1>
      
      <time class="f6 mv4 dib tracked" datetime="2019-07-04T08:00:00-04:00">July 4, 2019</time>
    </header>

    <main class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h2 id="introduction">Introduction</h2>

<p>To keep the research in , I started some basic repository with
the some official Rust book code compilation, I will try in this post comment
some of the features and tricks I got while reading it:</p>

<h5 id="https-github-com-knabben-spec-lang-tree-master-go">https://github.com/knabben/spec-lang/tree/master/go</h5>

<h5 id="https-github-com-knabben-spec-lang-tree-master-rust">https://github.com/knabben/spec-lang/tree/master/rust</h5>

<h2 id="guess">Guess</h2>

<h3 id="tag-0-0-1">Tag 0.0.1</h3>

<p>println! is used to send the value to stdout.</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> guess <span style="color:#f92672">=</span> String::new();
</code></pre></div>

<p>For rust you can create an immutable and a mutable variable, this is defined with the <strong>mut</strong> keyword
in front.</p>

<p>And the <strong>::new</strong> syntax indicates that new is an associated function of the String type.</p>

<p>The & indicates this argument is a reference, which gives you a way to let multiple parts
of your code access one piece of data without needing to copy that data into memory
multiple times. For now you need to write &mut guess rather than &guess to make it mutable.</p>

<p>read_line returns io::Result besides saving the value to the guess variable. The result types
are enumrations, often referred to as enums. An enumeration is a type that can have a fixed
set a values, and those values are called the enum's variants.</p>

<p>For Result, the variants are Ok or Err. Ok variant indicates the operation was successful,
and inside Ok is the successfully generated value. The Err variant means the operation failed
 and Err contains information about how or why the operation failed.</p>

<p>If the instance of io::Result is an Err value expect will crash and display the message
on error.</p>

<h3 id="tag-0-0-2">Tag 0.0.2</h3>

<p>Generating a random number, for rust is necessary a new crate or external dependency - rand, 
extern crate rand is used to bring the dependency to the file and the import is made in use rand::Rng;</p>

<p>We use match expression to decide what to do next based on which variant of Ordering, it has the 
variants of Less, Greater and Equal.</p>

<p>To finish there's the conversion of the guess variable from string to u32, so the parse method parses a string
into some number u32. Nothing so interesting here.</p>

<h2 id="ownership">Ownership</h2>

<p>Unique feature on Rust, enables to make memory safety guarantees without needing a GC.</p>

<h5 id="each-value-in-rust-has-a-variable-that-s-called-its-owner">Each value in Rust has a variable that's called its <strong>owner</strong></h5>

<h5 id="there-can-only-be-one-owner-at-a-time">There can only be one owner at a time.</h5>

<h5 id="when-the-owner-goes-out-of-scope-the-value-will-be-dropped">When the owner goes out of scope, the value will be dropped.</h5>

<p>Ampersands are <strong>references</strong> they allow you to refer to some value without taking ownership of it. 
Borrowing is having references as function parameters.</p>

<p>At any given time you can have either one mutable referente or any number of immutable references.
They must always be valid.</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">  <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">another_function</span>(y: <span style="color:#66d9ef">i32</span>, s: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> String) -&gt; <span style="color:#66d9ef">&amp;</span>String{
      println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{} {} - another&#34;</span>, y, s);
      s.push_str(<span style="color:#e6db74">&#34; - changed&#34;</span>);
      s
  }

  <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
      <span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
      <span style="color:#66d9ef">let</span> y <span style="color:#f92672">=</span> x;

      <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> s <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello&#34;</span>);
      <span style="color:#66d9ef">let</span> s_cloned <span style="color:#f92672">=</span> s.clone();

      another_function(y, <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> s);

      <span style="color:#66d9ef">let</span> r1 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>s;
      <span style="color:#66d9ef">let</span> r2 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>s;

      println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{} | {}&#34;</span>, r1, r2);
      println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{} | {} | {}&#34;</span>, s, s_cloned, y)
  } <span style="color:#75715e">// this scope is over and s/s_cloned is no longer valid
</span></code></pre></div>

<p>Slices references to part of a string, and they look like:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">  <span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello world&#34;</span>);
  <span style="color:#66d9ef">let</span> hello <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>s[<span style="color:#ae81ff">0</span>..<span style="color:#ae81ff">5</span>];

  <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">slice_function</span>(s: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span> {
      <span style="color:#f92672">&amp;</span>s[<span style="color:#ae81ff">6</span>..]
  }

  <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
      <span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello, world&#34;</span>);
      <span style="color:#66d9ef">let</span> r <span style="color:#f92672">=</span> slice_function(<span style="color:#f92672">&amp;</span>s[..]);
      println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, r)
  }
</code></pre></div>

<h2 id="struct">Struct</h2>

<p>A custom data type that lets you name and package together multiple related values that make up
a meaninful group.</p>

<p>Default format with #[derive(Debug)]</p>

<p>impl used for bring methods to a struct and associated functions to bring</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[derive(Debug)]</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Rectangle</span> {
    width: <span style="color:#66d9ef">u32</span>,
    height: <span style="color:#66d9ef">u32</span>,
}

<span style="color:#66d9ef">impl</span> Rectangle {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">area</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">u32</span> {
        self.width <span style="color:#f92672">*</span> self.height
    }

    <span style="color:#75715e">// associate function
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">square</span>(size: <span style="color:#66d9ef">u32</span>) -&gt; <span style="color:#a6e22e">Rectangle</span> {
        Rectangle { width: <span style="color:#a6e22e">size</span>, height: <span style="color:#a6e22e">size</span> }
    }

    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">can_hold</span>(<span style="color:#f92672">&amp;</span>self, other: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Rectangle</span>) -&gt; <span style="color:#66d9ef">bool</span> {
        self.height <span style="color:#f92672">&gt;</span> other.height <span style="color:#f92672">&amp;&amp;</span> self.width <span style="color:#f92672">&gt;</span> other.height
    }
}
</code></pre></div>

<h2 id="generic-types-traits-and-lifetimes">Generic types, traits and lifetimes</h2>

<p>For duplication of concepts we have generics. they are abstract stand-ins for concrete types or other properties.</p>

<p>Functions can take paramters of some generic type instead of a concrete type like i32 or String.</p>

<p>Traits are used to define behavior in a generic way. Lifetimes are a variety of generics that give the compiler
information about how references relate to each other. Allowign to borrow values in many situations whiel enabling the 
compiler to check that the reference are valid.</p>

<p>In struct definitions generics can be used</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Point</span><span style="color:#f92672">&lt;</span>T, U<span style="color:#f92672">&gt;</span> {
    x: <span style="color:#a6e22e">T</span>,
    y: <span style="color:#a6e22e">U</span>,
}

<span style="color:#66d9ef">let</span> integer <span style="color:#f92672">=</span> Point {x: <span style="color:#ae81ff">5</span>, y: <span style="color:#ae81ff">6</span>};
<span style="color:#66d9ef">let</span> float <span style="color:#f92672">=</span> Point {x: <span style="color:#ae81ff">1.0</span>, y: <span style="color:#ae81ff">4.0</span>};

<span style="color:#66d9ef">enum</span> Result<span style="color:#f92672">&lt;</span>T, E<span style="color:#f92672">&gt;</span> {
    Ok(T),
    Err(E),
}
</code></pre></div>

<p>Traits are similar to a feature often called interfaces in other languages.</p>

<h2 id="grep">Grep</h2>

<h3 id="tag-0-0-3">Tag 0.0.3</h3>

<p>Building a grep expect treats the error exception for a file not found only.</p>

<p>read_to_string dumps the file read to a contents mutable variable</p>

<h4 id="https-github-com-knabben-spec-lang-blob-0-0-3-rust-minigrep-src-main-rs-l18">https://github.com/knabben/spec-lang/blob/0.0.3/rust/minigrep/src/main.rs#L18</h4>

<p>Not much to see here.</p>

<h3 id="tag-0-0-4">Tag 0.0.4</h3>

<p>Refactoring for modularity and error handling, the basics will be splitting the function in two
the run/main functions and implemented a new struct to hold the args.</p>

<p>The run functions returns a trait object Box<Error>, means the functions will
return a type that implements the Error trait, but we don't have to specify
what particular type the return value will be.</p>

<p>Removed the expect in favor of the ? operator, it will return the error value
from the current function for the caller to handle.</p>

<h2 id="conclusion">Conclusion</h2>

<p>The memory management of rust is an incredible feature that can provide
the developer more trust on the final code.</p>

<p>If you are interested in the tutorial:</p>

<p>https://doc.rust-lang.org/book/ch12-00-an-io-project.html</p>

<p>The book is free and a good read:</p>

<p>https://doc.rust-lang.org/book/</p>
<ul class="pa0">
  
</ul>
<div class="mt6">
        
      </div>
    </main>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <script type="text/javascript" async
        src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
 MathJax.Hub.Config({
   tex2jax: {
     inlineMath: [['$','$'], ['\\(','\\)']],
     displayMath: [['$$','$$']],
     processEscapes: true,
     processEnvironments: true,
     skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
     TeX: { equationNumbers: { autoNumber: "AMS" },
            extensions: ["AMSmath.js", "AMSsymbols.js"] }
   }
 });
 MathJax.Hub.Queue(function() {
   
   
   
   var all = MathJax.Hub.getAllJax(), i;
   for(i = 0; i < all.length; i += 1) {
     all[i].SourceElement().parentNode.className += ' has-jax';
   }
 });

 MathJax.Hub.Config({
   
   TeX: { equationNumbers: { autoNumber: "AMS" } }
 });
</script>

<footer class="bg-near-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://knabben.github.io/" >
    &copy; 2019 AK
  </a>
    <div>








</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
