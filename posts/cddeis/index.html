<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>AK  | Continuous Deployment and DEIS</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.54.0" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.e08a958ae3e530145318b6373195c765.css" rel="stylesheet">
    

    
      <link rel="stylesheet" href="/css/custom.css">
    

    
      
    

    

    <meta property="og:title" content="Continuous Deployment and DEIS" />
<meta property="og:description" content="Introduction Continuous Deployment and Continuous Integration are topics that you can evolve and improve forever. The best reading on it IMO is [1] by Jez Humble, and it will be the guide for this post.
&#34;The time from deciding that you need to make a change to having it in production is known as the cycle time, and it is a vital metric for any project.&#34;
What we want here is do reduce the cycle time of the project in a reliable, secure and low-risk way, an automated process that is trusted enough to not be rolledback." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://knabben.github.io/posts/cddeis/" />
<meta property="article:published_time" content="2016-11-27T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2016-11-27T00:00:00&#43;00:00"/>

<meta itemprop="name" content="Continuous Deployment and DEIS">
<meta itemprop="description" content="Introduction Continuous Deployment and Continuous Integration are topics that you can evolve and improve forever. The best reading on it IMO is [1] by Jez Humble, and it will be the guide for this post.
&#34;The time from deciding that you need to make a change to having it in production is known as the cycle time, and it is a vital metric for any project.&#34;
What we want here is do reduce the cycle time of the project in a reliable, secure and low-risk way, an automated process that is trusted enough to not be rolledback.">


<meta itemprop="datePublished" content="2016-11-27T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2016-11-27T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="2323">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Continuous Deployment and DEIS"/>
<meta name="twitter:description" content="Introduction Continuous Deployment and Continuous Integration are topics that you can evolve and improve forever. The best reading on it IMO is [1] by Jez Humble, and it will be the guide for this post.
&#34;The time from deciding that you need to make a change to having it in production is known as the cycle time, and it is a vital metric for any project.&#34;
What we want here is do reduce the cycle time of the project in a reliable, secure and low-risk way, an automated process that is trusted enough to not be rolledback."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="http://knabben.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      AK
    </a>
    <div class="flex-l items-center">
      
      









    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  <article class="flex-l flex-wrap justify-between mw8 center ph3 ph0-l">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        POSTS
      </p>
      <h1 class="f1 athelas mb1">Continuous Deployment and DEIS</h1>
      
      <time class="f6 mv4 dib tracked" datetime="2016-11-27T00:00:00Z">November 27, 2016</time>
    </header>

    <main class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h2 id="introduction">Introduction</h2>

<p>Continuous Deployment and Continuous Integration are topics that you can evolve and improve forever. The best reading on it IMO is [1] by Jez Humble, and it will be the guide for this post.</p>

<p>"The time from deciding that you need to make a change to having it in production is known as the cycle time, and it is a vital metric for any project."</p>

<p>What we want here is do reduce the cycle time of the project in a reliable, secure and low-risk way, an automated process that is trusted enough to not be rolledback.</p>

<p>It means you are going to need a good deployment pipeline with lots of software testing before making the shine feature in production.</p>

<p>Some other stuff counts here like metrics visibility, easy triggers to start the process, etc.</p>

<h2 id="deployment-pipeline">Deployment Pipeline</h2>

<p>1) Commit stage - This stage normally is holded by a CI process, it creates the artifact, to be used by the pipeline.</p>

<p>2) Automated Acceptance testing - You should have a staging environment for this kind of tests, it means you must create an environment equals your production to run it.</p>

<p>3) Automated capacity testing - The same env is used here, you can use tools like Tsung, jmeter.</p>

<p>4) Manual testing (exploratory) - So it expects that you have your last step, to find bugs navigating on the system.</p>

<p>5) Release - Deploy it!</p>

<p>"Automation is the key. It allows all of the common tasks involved in the creation and deployment of software to be performed by developers, testers, and operations personnel, at the push of a button.</p>

<p>When deployments arenâ€™t fully automated, errors will occur every time they are performed. The only question is whether or not the errors are significant. Even with excellent deployment tests, bugs can be hard to track down. When the deployment process is not automated, it is not repeatable or reliable, leading to time wasted on debugging deployment errors."</p>

<p>Again speed here counts because you cannot make money without the feature or bugfix in production.</p>

<p>Every change (or commit) should trigger the pipeline, the artifact resulted from the CI pipeline should be tested before going to the release.</p>

<p>The principal benefit of the approach that we describe in the preceding section is that it creates a release process that is repeatable, reliable, and predictable, which in turn generates large reductions in cycle time, and hence gets features and bugfixes to users fast. The cost savings alone are worth not just the cover price of this book, but also the investment in time that the establishment and maintenance of such a release system entails.</p>

<p>The best advise of the book: If It Hurts, Do It More Frequently, and Bring the Pain Forward.</p>

<h2 id="configuration-management">Configuration Management</h2>

<p>It is the way you have a baseline for your servers, how you have the certainty that package X is installed or removed from your system, that the service Y will be UP. It is how you mantain a initial state for you OS in an automated way. We have a lot of CM systems out there: Ansible, Puppet, Chef...</p>

<p>With the tools borned the concept of IaC (infrastructure as a code), you now can model your infrastructure assets in a dependendable fashion, in any environment (bare-metal, private/public cloud), and make sure all boxes remains the same.</p>

<p>To make sure you have this implemented Jez makes a good question: Can you be sure that each deployed environment in production, in stagin and in test is set up in precisely same way? Could you regress to an earlier know good state of your app?</p>

<h2 id="continuous-integration">Continuous Integration</h2>

<p>The goal of CI is to keep everyone in sync with each other, which we achieve by making sure that newly checked-in code propery integrates with existing code. [2]</p>

<p>Here you can use tools like TravisCI or Jenkins to merge your fix branches on the master, run all unit tests and create the artifact from it. The trick here is process feedbacks, it is the first part of the pipeline and if you have it very concrete it should be the base to the rest.</p>

<h2 id="deployment-of-modern-apps">Deployment of modern apps</h2>

<p>When the book were wrote Docker, (2013) didn't existed yet, even the 12-factor methodology (2012), so things in this field are VERY new, as the concept of microservices as well.</p>

<p>People are still discovering and adapting how these processes can work with these new technology. A good example is Deis: a lightweight application platform that deploys and scales 12-factor apps as Docker and containers across a cluster of CoreOS machines.</p>

<p>So to resume: the 12-factor methodology is a composition of the best practices from the CI/CD process for modern application and Deis uses great technologies like CoreOS and Docker to make it practical, on other posts we will analyze how it is implemented.</p>

<p>As stated on Chapter 6 of Building Microservices, deploying a monolithic app is a fairly straighforward process. Microservices, with their interdependence, are a different kettle of fish altogether. If you don't approach deployment right, it's one of those areas where the complexity can make your life a misery.</p>

<h2 id="deis-and-concrete-processes">DEIS and concrete processes</h2>

<p>Make CI/CD systems well integrated with your infrastructure is a complex task, things get worse when these systems must be modularized and easy to adapt to your deploy pipeline. You have a lot of rowing up applications with different requirements, code and ways to run. This layer on top of your infrastructure is now known as PaaS, Heroku is a great example of how you can abstract the complexity of running a new app in 2 or 3 commands. It should be awesome to have the same capability on your hands and control of the stack, this way you can modify or replace pieces in a transparent way. For the company they probably will have to worry about the total cost of ownership and good people to manage it.</p>

<p>Some examples of opensource software in the market to achieve it: Jenkins Pipeline and the guys from CloudBee [1] made a good job with it, you can run slaves as Kubernetes pods for example, and create stages in a very dynamic way for your pipeline.</p>

<p>DEIS workflow and its microserviced architecture [2]: a Heroku SDK for Kubernetes, they have very detailed documentation worth to read, I am going to explain the general parts on this article.</p>

<p>The guys from DEIS have other project pretty much interesting called HELM, it is much more simple than Deis Workflow, think of it as a package manager for Kubernetes.</p>

<h2 id="settings-up-the-kubernetes-cluster">Settings up the Kubernetes Cluster</h2>

<p>We are using the "new" kubeadm tool to setup the cluster on a Debian machines for development, take a look on the documentation but you can run this script to have it up:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e">#!/bin/bash
</span><span style="color:#75715e"></span>
<span style="color:#75715e"># Remove old kubeadm stuff</span>
kubeadm reset
systemctl restart kubelet

kubeadm init

<span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> -f /etc/kubernetes/kubelet.conf <span style="color:#f92672">]</span>
<span style="color:#66d9ef">then</span>
	export KUBECONFIG<span style="color:#f92672">=</span>/etc/kubernetes/kubelet.conf
<span style="color:#66d9ef">fi</span>

<span style="color:#75715e"># Create pod network</span>
kubectl apply -f https://git.io/weave-kube
<span style="color:#75715e"># Enable pods start</span>
kubectl taint nodes --all dedicated-</code></pre></div>

<p>So far so good, you have a bunch of docker containers check it with ps or try to run a new 'kubectl run nginx --image=nginx'</p>

<p>We can start Deis with the following helmc script:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ helmc generate workflow-v2.8.0
$ helmc install workflow-v2.8.0

NAME                                     READY     STATUS    RESTARTS   AGE
deis-builder-415246326-97ioi             <span style="color:#ae81ff">1</span>/1       Running   <span style="color:#ae81ff">13</span>         15h
deis-controller-1590631305-rqev9         <span style="color:#ae81ff">1</span>/1       Running   <span style="color:#ae81ff">13</span>         15h
deis-database-510315365-3oro8            <span style="color:#ae81ff">1</span>/1       Running   <span style="color:#ae81ff">7</span>          15h
deis-logger-9212198-n38h8                <span style="color:#ae81ff">1</span>/1       Running   <span style="color:#ae81ff">17</span>         15h
deis-logger-fluentd-mny1o                <span style="color:#ae81ff">1</span>/1       Running   <span style="color:#ae81ff">4</span>          15h
deis-logger-redis-663064164-jm8fx        <span style="color:#ae81ff">1</span>/1       Running   <span style="color:#ae81ff">4</span>          15h
deis-minio-3160338312-oxhp9              <span style="color:#ae81ff">1</span>/1       Running   <span style="color:#ae81ff">4</span>          15h
deis-monitor-grafana-432364990-fieg8     <span style="color:#ae81ff">1</span>/1       Running   <span style="color:#ae81ff">4</span>          15h
deis-monitor-influxdb-2729526471-d7v66   <span style="color:#ae81ff">1</span>/1       Running   <span style="color:#ae81ff">4</span>          15h
deis-monitor-telegraf-d3gva              <span style="color:#ae81ff">1</span>/1       Running   <span style="color:#ae81ff">14</span>         15h
deis-nsqd-3264449345-inu6p               <span style="color:#ae81ff">1</span>/1       Running   <span style="color:#ae81ff">4</span>          15h
deis-registry-2182132043-5go81           <span style="color:#ae81ff">1</span>/1       Running   <span style="color:#ae81ff">14</span>         15h
deis-registry-proxy-s6aph                <span style="color:#ae81ff">1</span>/1       Running   <span style="color:#ae81ff">4</span>          15h
deis-router-2457652422-tznjt             <span style="color:#ae81ff">1</span>/1       Running   <span style="color:#ae81ff">6</span>          15h
deis-workflow-manager-2210821749-4lqkp   <span style="color:#ae81ff">1</span>/1       Running   <span style="color:#ae81ff">4</span>          15h</code></pre></div>

<h2 id="build-release-run">Build, Release, Run</h2>

<p>Take a look on [3], you can see the flow diagram of how DEIS workflow behaves, and provide to the developer a simple interface for deployments.</p>

<p>The principal idea here is a release. One of the problems faced with raw kubernetes deployments is when you have to update/change your mounted secret on an environemnt variable, it doesn't reflect direct on your pod, so you have to restart or redeploy it manually. With DEIS a release can be a code change or a configuration change, if one of these change a new release is deployed.</p>

<p>Basically DEIS workflow have a gitserver with some hooks ("git-receive-pack", "git-upload-pack"), after you push your git repo to the system, the system detects your build type (dockerbuild or slugbuilds) and create a new pod that builds the artifact, DEIS controller in the end will start a deployment object on your Kubernetes cluster.</p>

<h2 id="deis-register">DEIS register</h2>

<p>The operator frontend is a command line called "deis". On deis/workflow-cli repo, exists a folder called cmd, on auth.go we find the Register func, these files are more a wrapper and the initial glue for the logic business, deis/controller-skd-go has the sdk. IF you follow the stack via auth.go:64 you hit controller-sdk.go auth.Register it calls "/v2/auth/register/" on your controller.</p>

<p>First of all we need to find the router IP service via "kubectl --namespace=deis describe svc deis-router", and use it to call the register command: "deis register http://deis.10.6.40.159.nip.io".</p>

<p>If you start your domain with the app name like: app.10.6.40.19.nip.io, workflow router will handle it and route to your application. DEIS will label router.deis.io/routable: "true" on each service you want to route packets to.</p>

<p>Going back to the register namespace on the controller, we have a Django (Rest Framework) app with a PostgreSQL database, that stores all configurations.</p>

<p>It is possible to replace parts of your cluster for a development one in a few "make deploy" command. Or you can customize it on the Helm Classic installation.</p>

<h2 id="deis-and-the-apps">DEIS and the apps</h2>

<p>Going through the flow we find the create command, again take a look on AppCreate and controller-sdk-go/apps, func New, here it makes a POST on Django <em>v2/apps</em> it basically create a new api_apps row on PostgreSQL db. With the app created you can start releases and set other configurations.</p>

<p>After register a new user and login the system, you have to put your publickey on DEIS to be able to push code.</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">deis keys:add ~/.key.pub</code></pre></div>

<p>When you create a new app (deis create yourapp), a remote git repository will be created and point to your builder host (port 2222). All you need to do is push your local repo to the remote:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git push origin deis</code></pre></div>

<h2 id="builder-and-slugs">Builder and slugs</h2>

<p>DEIS Builder will handle your request and based on the server hooks start the builder pod, suppose we are using a Dockerfile commited on the project, lets take a look on the dockerbuild file:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">...
<span style="color:#75715e"># The .tar.gz file artifact is fetched from the Builder Storage</span>
with tarfile.open<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;apptar&#34;</span>, <span style="color:#e6db74">&#34;r:gz&#34;</span><span style="color:#f92672">)</span> as tar:
    tar.extractall<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;/app/&#34;</span><span style="color:#f92672">)</span>

<span style="color:#75715e"># Use docker api to build and push docker to registry</span>
client <span style="color:#f92672">=</span> docker.Client<span style="color:#f92672">(</span>version<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;auto&#39;</span><span style="color:#f92672">)</span>
registry <span style="color:#f92672">=</span> get_registry_name<span style="color:#f92672">()</span>
imageName, imageTag <span style="color:#f92672">=</span> os.getenv<span style="color:#f92672">(</span><span style="color:#e6db74">&#39;IMG_NAME&#39;</span><span style="color:#f92672">)</span>.split<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;:&#34;</span>, <span style="color:#ae81ff">1</span><span style="color:#f92672">)</span>
repo <span style="color:#f92672">=</span> registry + <span style="color:#e6db74">&#34;/&#34;</span> + os.getenv<span style="color:#f92672">(</span><span style="color:#e6db74">&#39;IMG_NAME&#39;</span><span style="color:#f92672">)</span>
stream <span style="color:#f92672">=</span> client.build<span style="color:#f92672">(</span>tag<span style="color:#f92672">=</span>repo, stream<span style="color:#f92672">=</span>True, decode<span style="color:#f92672">=</span>True, rm<span style="color:#f92672">=</span>True, pull<span style="color:#f92672">=</span>True, path<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;/app&#39;</span><span style="color:#f92672">)</span>
log_output<span style="color:#f92672">(</span>stream, True<span style="color:#f92672">)</span>
print<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Pushing to registry&#34;</span><span style="color:#f92672">)</span>
stream <span style="color:#f92672">=</span> client.push<span style="color:#f92672">(</span>registry+<span style="color:#e6db74">&#39;/&#39;</span>+imageName, tag<span style="color:#f92672">=</span>imageTag, stream<span style="color:#f92672">=</span>True<span style="color:#f92672">)</span>
...</code></pre></div>

<p>PS: In production I really recommend to use ECR (external docker repository) and an external artifacts storage, take a look on ~/.helmc/workflow/charts/workflow-v2.8.0/tpl/generate_params.toml, otherwise you can full your disk very fast:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">storage <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;s3&#34;</span>
repository_location <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;ecr&#34;</span>

<span style="color:#f92672">[</span>ecr<span style="color:#f92672">]</span>
region <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;us-east-1&#34;</span>
hostname <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;...ecr.us-east-1.amazonaws.com&#34;</span>

<span style="color:#f92672">[</span>s3<span style="color:#f92672">]</span>
registry_bucket <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;deisregistry&#34;</span>  <span style="color:#75715e"># Docker Registry</span>
database_bucket <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;deisdb&#34;</span>  <span style="color:#75715e"># PGSql backups</span>
builder_bucket <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;deisbuild&#34;</span>  <span style="color:#75715e"># Artifacts</span></code></pre></div>

<p>PS2: You can have a similar JOB on jenkins pipeline, something like:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">node <span style="color:#f92672">{</span>
	stage <span style="color:#e6db74">&#39;login&#39;</span>
	sh <span style="color:#e6db74">&#39;$(aws ecr get-login)&#39;</span>

    stage <span style="color:#e6db74">&#39;git&#39;</span>
	dir<span style="color:#f92672">(</span><span style="color:#e6db74">&#39;project&#39;</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
		git credentialsId: <span style="color:#e6db74">&#39;xxx&#39;</span>, url: <span style="color:#e6db74">&#39;git@github.com:comp/proj&#39;</span>
	<span style="color:#f92672">}</span>

	stage <span style="color:#e6db74">&#39;build_push&#39;</span>
	docker.withRegistry<span style="color:#f92672">(</span><span style="color:#e6db74">&#39;http://..us-east-1.amazonaws.com&#39;</span>, <span style="color:#e6db74">&#39;proj&#39;</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
		def proj <span style="color:#f92672">=</span> docker.build<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;proj:</span><span style="color:#e6db74">${</span>env.BUILD_NUMBER<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74">&#34;.&#34;</span><span style="color:#f92672">)</span>
		proj.push<span style="color:#f92672">()</span>
	<span style="color:#f92672">}</span>
<span style="color:#f92672">}</span></code></pre></div>

<p>I have the artifact and now? Step back and ask again: I have the artifact, how? The answer is the func build on pkg/gitreceive/build.go, it started the build pod watched it run outputed the logs and launched it with hook.CreateBuild, here we came back again to the controller pod c.Request("POST", "/v2/hooks/build/", b), can you see what da heck if microservices?</p>

<h2 id="back-to-the-controller">Back to the controller</h2>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">urls<span style="color:#f92672">.</span>py
url(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#39;^hooks/build/?$&#39;</span>, views<span style="color:#f92672">.</span>BuildHookViewSet<span style="color:#f92672">.</span>as_view({<span style="color:#e6db74">&#39;post&#39;</span>: <span style="color:#e6db74">&#39;create&#39;</span>})),

To resume the stack<span style="color:#f92672">-</span> <span style="color:#f92672">&gt;</span> BuildHookViewSet <span style="color:#f92672">-&gt;</span> starts a new Build object <span style="color:#f92672">and</span> <span style="color:#66d9ef">with</span> a post_save signal starts a new release <span style="color:#66d9ef">with</span> models<span style="color:#f92672">/</span>build<span style="color:#f92672">.</span>py:<span style="color:#ae81ff">65</span>

self<span style="color:#f92672">.</span>app<span style="color:#f92672">.</span>deploy(new_release)

models<span style="color:#f92672">/</span>app<span style="color:#f92672">.</span>py:<span style="color:#ae81ff">446</span> <span style="color:#66d9ef">as</span> a FK of the build<span style="color:#f92672">.</span> lets deploy a new revision of the app<span style="color:#f92672">.</span>

tasks <span style="color:#f92672">=</span> [
	functools<span style="color:#f92672">.</span>partial(
		self<span style="color:#f92672">.</span>_scheduler<span style="color:#f92672">.</span>deploy,
		namespace<span style="color:#f92672">=</span>self<span style="color:#f92672">.</span>id,
		name<span style="color:#f92672">=</span>self<span style="color:#f92672">.</span>_get_job_id(scale_type),
		image<span style="color:#f92672">=</span>image,
		entrypoint<span style="color:#f92672">=</span>self<span style="color:#f92672">.</span>_get_entrypoint(scale_type),
		command<span style="color:#f92672">=</span>self<span style="color:#f92672">.</span>_get_command(scale_type),
		<span style="color:#f92672">**</span>kwargs
	) <span style="color:#66d9ef">for</span> scale_type, kwargs <span style="color:#f92672">in</span> deploys<span style="color:#f92672">.</span>items()
]

async_run(tasks)  <span style="color:#75715e"># Just a bunch of asyncio threads</span></code></pre></div>

<p>The _scheduler object here looks interesting, the AuditModel (parent of App) do importlib.import_module(settings.SCHEDULER_MODULE) on scheduler property, the scheduler module starts the KubeHTTPClient and the deploy creates/update a deployment Kubernetes via REST API with some custom data.</p>

<h2 id="3rd-party-integration">3rd party integration</h2>

<p>A dashboard [5] can be useful for log analysis for example, DEIS comes integrated with fluentd for log and grafana + influxdb for metrics and monitoring.</p>

<h2 id="helm">HELM</h2>

<p>Helm 2.0 [6] is Kubernetes package manager build by DEIS, you can find some ready Charts, kudos to the Jenkins one:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">helm install stable/jenkins</code></pre></div>

<p>You can start your own helm with create and manage the deployments with upgrade, releases and etc. Another good project on top of kubernetes to keep the eye on.</p>

<h2 id="conclusion">Conclusion</h2>

<p>DEIS Workflow provides a very cool PaaS environment for the end lazy developer, normally peopl don't give a shit about the stack behind their code, and just want to run it. So DEIS is the option with some custom configuration and an extended dashboard you can provide a good self-service model of deployment.</p>

<p>HELM is a Kubernetes package manager, a bunch of templates with custom configuration where you can replicate the "deployment" in a few commands, you don't have any fancy stack to start things, but is awesome to automate and reply your software in a ease way.</p>

<p>Follow the Sig-APPS community for the latest news.</p>

<h2 id="listening">Listening</h2>

<p><iframe width="420" height="315" src="http://www.youtube.com/embed/2wOWSM8VT0A" frameborder="0" allowfullscreen></iframe></p>

<h2 id="bibliography">Bibliography</h2>

<h5 id="1-https-www-amazon-com-continuous-delivery-deployment-automation-addison-wesley-dp-0321601912-183-9249231-2275620-ie-utf8-redirect-true">[1] https://www.amazon.com/Continuous-Delivery-Deployment-Automation-Addison-Wesley/dp/0321601912/183-9249231-2275620?ie=UTF8&redirect=true</h5>

<h5 id="2-building-microservices">[2] Building Microservices</h5>

<h5 id="3-https-www-cloudbees-com-continuous-delivery-jenkins-docker">[3] https://www.cloudbees.com/continuous-delivery/jenkins-docker</h5>

<h5 id="4-http-deis-com-workflow">[4] http://deis.com/workflow/</h5>

<h5 id="5-https-deis-com-docs-workflow-understanding-workflow-concepts-build-release-run">[5] https://deis.com/docs/workflow/understanding-workflow/concepts/#build-release-run</h5>

<h5 id="6-https-github-com-deis-builder">[6] https://github.com/deis/builder</h5>

<h5 id="7-https-github-com-olalonde-deisdash">[7] https://github.com/olalonde/deisdash</h5>

<h5 id="8-http-helm-sh">[8] http://helm.sh</h5>

<h5 id="9-https-github-com-kubernetes-community-tree-master-sig-apps">[9] https://github.com/kubernetes/community/tree/master/sig-apps</h5>
<ul class="pa0">
  
</ul>
<div class="mt6">
        
      </div>
    </main>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <script type="text/javascript" async
        src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
 MathJax.Hub.Config({
   tex2jax: {
     inlineMath: [['$','$'], ['\\(','\\)']],
     displayMath: [['$$','$$']],
     processEscapes: true,
     processEnvironments: true,
     skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
     TeX: { equationNumbers: { autoNumber: "AMS" },
            extensions: ["AMSmath.js", "AMSsymbols.js"] }
   }
 });
 MathJax.Hub.Queue(function() {
   
   
   
   var all = MathJax.Hub.getAllJax(), i;
   for(i = 0; i < all.length; i += 1) {
     all[i].SourceElement().parentNode.className += ' has-jax';
   }
 });

 MathJax.Hub.Config({
   
   TeX: { equationNumbers: { autoNumber: "AMS" } }
 });
</script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-46699622-2', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<footer class="bg-near-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://knabben.github.io/" >
    &copy; 2019 AK
  </a>
    <div>








</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
